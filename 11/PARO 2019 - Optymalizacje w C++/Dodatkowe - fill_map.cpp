#include <map>
#include <tuple>
#include <utility>

using map_type = std::map<int, int>;

static void test_initialization_list(benchmark::State& state) {
	for (auto _ : state) {
		map_type map{
#define ENTRY(x) { x, x },
			ENTRY(0)
			ENTRY(1)
			ENTRY(2)
			ENTRY(3)
			ENTRY(4)
			ENTRY(5)
			ENTRY(6)
			ENTRY(7)
			ENTRY(8)
			ENTRY(9)
			ENTRY(10)
			ENTRY(11)
			ENTRY(12)
			ENTRY(13)
			ENTRY(14)
			ENTRY(15)
			ENTRY(16)
			ENTRY(17)
			ENTRY(18)
			ENTRY(19)
			ENTRY(20)
			ENTRY(21)
			ENTRY(22)
			ENTRY(23)
			ENTRY(24)
			ENTRY(25)
			ENTRY(26)
			ENTRY(27)
			ENTRY(28)
			ENTRY(29)
			ENTRY(30)
			ENTRY(31)
			ENTRY(32)
			ENTRY(33)
			ENTRY(34)
			ENTRY(35)
			ENTRY(36)
			ENTRY(37)
			ENTRY(38)
			ENTRY(39)
			ENTRY(40)
			ENTRY(41)
			ENTRY(42)
			ENTRY(43)
			ENTRY(44)
			ENTRY(45)
			ENTRY(46)
			ENTRY(47)
			ENTRY(48)
			ENTRY(49)
#undef ENTRY
		};
		benchmark::DoNotOptimize(map);
	}
}
BENCHMARK(test_initialization_list);

static void test_insert(benchmark::State& state) {
	for (auto _ : state) {
		map_type map{};
#define ENTRY(x) map.insert(map_type::value_type{ x, x });
		ENTRY(0)
		ENTRY(1)
		ENTRY(2)
		ENTRY(3)
		ENTRY(4)
		ENTRY(5)
		ENTRY(6)
		ENTRY(7)
		ENTRY(8)
		ENTRY(9)
		ENTRY(10)
		ENTRY(11)
		ENTRY(12)
		ENTRY(13)
		ENTRY(14)
		ENTRY(15)
		ENTRY(16)
		ENTRY(17)
		ENTRY(18)
		ENTRY(19)
		ENTRY(20)
		ENTRY(21)
		ENTRY(22)
		ENTRY(23)
		ENTRY(24)
		ENTRY(25)
		ENTRY(26)
		ENTRY(27)
		ENTRY(28)
		ENTRY(29)
		ENTRY(30)
		ENTRY(31)
		ENTRY(32)
		ENTRY(33)
		ENTRY(34)
		ENTRY(35)
		ENTRY(36)
		ENTRY(37)
		ENTRY(38)
		ENTRY(39)
		ENTRY(40)
		ENTRY(41)
		ENTRY(42)
		ENTRY(43)
		ENTRY(44)
		ENTRY(45)
		ENTRY(46)
		ENTRY(47)
		ENTRY(48)
		ENTRY(49)
#undef ENTRY
		benchmark::DoNotOptimize(map);
	}
}
BENCHMARK(test_insert);

static void test_insert_with_hint(benchmark::State& state) {
	for (auto _ : state) {
		map_type map{};
		auto it = map.end();
#define ENTRY(x) it = map.insert(it, map_type::value_type{ x, x });
		ENTRY(0)
		ENTRY(1)
		ENTRY(2)
		ENTRY(3)
		ENTRY(4)
		ENTRY(5)
		ENTRY(6)
		ENTRY(7)
		ENTRY(8)
		ENTRY(9)
		ENTRY(10)
		ENTRY(11)
		ENTRY(12)
		ENTRY(13)
		ENTRY(14)
		ENTRY(15)
		ENTRY(16)
		ENTRY(17)
		ENTRY(18)
		ENTRY(19)
		ENTRY(20)
		ENTRY(21)
		ENTRY(22)
		ENTRY(23)
		ENTRY(24)
		ENTRY(25)
		ENTRY(26)
		ENTRY(27)
		ENTRY(28)
		ENTRY(29)
		ENTRY(30)
		ENTRY(31)
		ENTRY(32)
		ENTRY(33)
		ENTRY(34)
		ENTRY(35)
		ENTRY(36)
		ENTRY(37)
		ENTRY(38)
		ENTRY(39)
		ENTRY(40)
		ENTRY(41)
		ENTRY(42)
		ENTRY(43)
		ENTRY(44)
		ENTRY(45)
		ENTRY(46)
		ENTRY(47)
		ENTRY(48)
		ENTRY(49)
#undef ENTRY
		benchmark::DoNotOptimize(map);
	}
}
BENCHMARK(test_insert_with_hint);

static void test_emplace(benchmark::State& state) {
	for (auto _ : state) {
		map_type map{};
#define ENTRY(x) map.emplace(map_type::value_type{ x, x });
		ENTRY(0)
		ENTRY(1)
		ENTRY(2)
		ENTRY(3)
		ENTRY(4)
		ENTRY(5)
		ENTRY(6)
		ENTRY(7)
		ENTRY(8)
		ENTRY(9)
		ENTRY(10)
		ENTRY(11)
		ENTRY(12)
		ENTRY(13)
		ENTRY(14)
		ENTRY(15)
		ENTRY(16)
		ENTRY(17)
		ENTRY(18)
		ENTRY(19)
		ENTRY(20)
		ENTRY(21)
		ENTRY(22)
		ENTRY(23)
		ENTRY(24)
		ENTRY(25)
		ENTRY(26)
		ENTRY(27)
		ENTRY(28)
		ENTRY(29)
		ENTRY(30)
		ENTRY(31)
		ENTRY(32)
		ENTRY(33)
		ENTRY(34)
		ENTRY(35)
		ENTRY(36)
		ENTRY(37)
		ENTRY(38)
		ENTRY(39)
		ENTRY(40)
		ENTRY(41)
		ENTRY(42)
		ENTRY(43)
		ENTRY(44)
		ENTRY(45)
		ENTRY(46)
		ENTRY(47)
		ENTRY(48)
		ENTRY(49)
#undef ENTRY
		benchmark::DoNotOptimize(map);
	}
}
BENCHMARK(test_emplace);

static void test_emplace_hint(benchmark::State& state) {
	for (auto _ : state) {
		map_type map{};
		auto it = map.end();
#define ENTRY(x) it = map.emplace_hint(it, map_type::value_type{ x, x });
		ENTRY(0)
		ENTRY(1)
		ENTRY(2)
		ENTRY(3)
		ENTRY(4)
		ENTRY(5)
		ENTRY(6)
		ENTRY(7)
		ENTRY(8)
		ENTRY(9)
		ENTRY(10)
		ENTRY(11)
		ENTRY(12)
		ENTRY(13)
		ENTRY(14)
		ENTRY(15)
		ENTRY(16)
		ENTRY(17)
		ENTRY(18)
		ENTRY(19)
		ENTRY(20)
		ENTRY(21)
		ENTRY(22)
		ENTRY(23)
		ENTRY(24)
		ENTRY(25)
		ENTRY(26)
		ENTRY(27)
		ENTRY(28)
		ENTRY(29)
		ENTRY(30)
		ENTRY(31)
		ENTRY(32)
		ENTRY(33)
		ENTRY(34)
		ENTRY(35)
		ENTRY(36)
		ENTRY(37)
		ENTRY(38)
		ENTRY(39)
		ENTRY(40)
		ENTRY(41)
		ENTRY(42)
		ENTRY(43)
		ENTRY(44)
		ENTRY(45)
		ENTRY(46)
		ENTRY(47)
		ENTRY(48)
		ENTRY(49)
#undef ENTRY
		benchmark::DoNotOptimize(map);
	}
}
BENCHMARK(test_emplace_hint);

static void test_emplace_piecewise(benchmark::State& state) {
	for (auto _ : state) {
		map_type map{};
#define ENTRY(x) map.emplace(std::piecewise_construct, std::forward_as_tuple(x), std::forward_as_tuple(x));
		ENTRY(0)
		ENTRY(1)
		ENTRY(2)
		ENTRY(3)
		ENTRY(4)
		ENTRY(5)
		ENTRY(6)
		ENTRY(7)
		ENTRY(8)
		ENTRY(9)
		ENTRY(10)
		ENTRY(11)
		ENTRY(12)
		ENTRY(13)
		ENTRY(14)
		ENTRY(15)
		ENTRY(16)
		ENTRY(17)
		ENTRY(18)
		ENTRY(19)
		ENTRY(20)
		ENTRY(21)
		ENTRY(22)
		ENTRY(23)
		ENTRY(24)
		ENTRY(25)
		ENTRY(26)
		ENTRY(27)
		ENTRY(28)
		ENTRY(29)
		ENTRY(30)
		ENTRY(31)
		ENTRY(32)
		ENTRY(33)
		ENTRY(34)
		ENTRY(35)
		ENTRY(36)
		ENTRY(37)
		ENTRY(38)
		ENTRY(39)
		ENTRY(40)
		ENTRY(41)
		ENTRY(42)
		ENTRY(43)
		ENTRY(44)
		ENTRY(45)
		ENTRY(46)
		ENTRY(47)
		ENTRY(48)
		ENTRY(49)
#undef ENTRY
		benchmark::DoNotOptimize(map);
	}
}
BENCHMARK(test_emplace_piecewise);

static void test_emplace_hint_piecewise(benchmark::State& state) {
	for (auto _ : state) {
		map_type map{};
		auto it = map.end();
#define ENTRY(x) it = map.emplace_hint(it, std::piecewise_construct, std::forward_as_tuple(x), std::forward_as_tuple(x));
		ENTRY(0)
		ENTRY(1)
		ENTRY(2)
		ENTRY(3)
		ENTRY(4)
		ENTRY(5)
		ENTRY(6)
		ENTRY(7)
		ENTRY(8)
		ENTRY(9)
		ENTRY(10)
		ENTRY(11)
		ENTRY(12)
		ENTRY(13)
		ENTRY(14)
		ENTRY(15)
		ENTRY(16)
		ENTRY(17)
		ENTRY(18)
		ENTRY(19)
		ENTRY(20)
		ENTRY(21)
		ENTRY(22)
		ENTRY(23)
		ENTRY(24)
		ENTRY(25)
		ENTRY(26)
		ENTRY(27)
		ENTRY(28)
		ENTRY(29)
		ENTRY(30)
		ENTRY(31)
		ENTRY(32)
		ENTRY(33)
		ENTRY(34)
		ENTRY(35)
		ENTRY(36)
		ENTRY(37)
		ENTRY(38)
		ENTRY(39)
		ENTRY(40)
		ENTRY(41)
		ENTRY(42)
		ENTRY(43)
		ENTRY(44)
		ENTRY(45)
		ENTRY(46)
		ENTRY(47)
		ENTRY(48)
		ENTRY(49)
#undef ENTRY
		benchmark::DoNotOptimize(map);
	}
}
BENCHMARK(test_emplace_hint_piecewise);
